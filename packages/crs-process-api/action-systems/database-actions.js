class f{static async perform(e,t,s,a){await this[e.action]?.(e,t,s,a)}static async open(e,t,s,a){let n=await crs.process.getValue(e.args.name,t,s,a);const r=await crs.process.getValue(e.args.version,t,s,a),l=await crs.process.getValue(e.args.tables,t,s,a);(await crs.process.getValue(e.args.add_timestamp,t,s,a)||!1)==!0&&(n=`${n}_TS${Date.now()}`);const o=g.open(n,r||1,l);return e.args.target!=null&&await crs.process.setValue(e.args.table,o,t,s,a),o}static async delete_old(e,t,s,a){const n=await crs.process.getValue(e.args.days,t,s,a)||1,r=await g.get_databases(),l=Date.now(),c=24*60*60*1e3;for(const o of r){const u=o.name;if(u.indexOf("_TS")==-1)continue;const i=Number(u.split("_TS")[1]);(l-i)/c>n&&g.delete(u)}}static async close(e,t,s,a){return(await crs.process.getValue(e.args.db,t,s,a)).close(),typeof e.args.db=="string"&&await crs.process.setValue(e.args.db,null,t,s,a),null}static async delete(e,t,s,a){const n=await crs.process.getValue(e.args.name,t,s,a);g.delete(n)}static async dump(e,t,s,a){const n=await crs.process.getValue(e.args.db,t,s,a),r=await crs.process.getValue(e.args.store,t,s,a),l=await crs.process.getValue(e.args.records,t,s,a);await n.dump(r,l)}static async get_from_index(e,t,s,a){const n=await crs.process.getValue(e.args.db,t,s,a),r=await crs.process.getValue(e.args.store,t,s,a),l=await crs.process.getValue(e.args.keys,t,s,a);let c=await n.get_from_index(r,l);return e.args.target!=null&&await crs.process.setValue(e.args.target,c,t,s,a),c}static async get_all(e,t,s,a){const n=await crs.process.getValue(e.args.db,t,s,a),r=await crs.process.getValue(e.args.store,t,s,a);let l=await n.get_all(r);return e.args.target!=null&&await crs.process.setValue(e.args.target,l,t,s,a),l}static async clear(e,t,s,a){const n=await crs.process.getValue(e.args.db,t,s,a),r=await crs.process.getValue(e.args.store,t,s,a);await n.clear(r)}static async delete_record(e,t,s,a){const n=await crs.process.getValue(e.args.db,t,s,a),r=await crs.process.getValue(e.args.store,t,s,a),l=await crs.process.getValue(e.args.key,t,s,a);await n.delete_record(r,l)}static async update_record(e,t,s,a){const n=await crs.process.getValue(e.args.db,t,s,a),r=await crs.process.getValue(e.args.store,t,s,a),l=await crs.process.getValue(e.args.key,t,s,a),c=await crs.process.getValue(e.args.model,t,s,a);await n.update_record(r,l,c)}static async add_record(e,t,s,a){const n=await crs.process.getValue(e.args.db,t,s,a),r=await crs.process.getValue(e.args.store,t,s,a),l=await crs.process.getValue(e.args.model,t,s,a);await n.add_record(r,l)}static async get_batch(e,t,s,a){const n=await crs.process.getValue(e.args.db,t,s,a),r=await crs.process.getValue(e.args.store,t,s,a),l=await crs.process.getValue(e.args.start,t,s,a),c=await crs.process.getValue(e.args.end,t,s,a);let o=await n.get_batch(r,l,c);return e.args.target!=null&&await crs.process.setValue(e.args.target,o,t,s,a),o}static async get_values(e,t,s,a){const n=await crs.process.getValue(e.args.db,t,s,a),r=await crs.process.getValue(e.args.store,t,s,a),l=await crs.process.getValue(e.args.fields,t,s,a),c=await crs.process.getValue(e.args.keys,t,s,a);let o=await n.get_values(r,l,c);return e.args.target!=null&&await crs.process.setValue(e.args.target,o,t,s,a),o}static async calculate_paging(e,t,s,a){const n=await crs.process.getValue(e.args.db,t,s,a),r=await crs.process.getValue(e.args.store,t,s,a),l=await crs.process.getValue(e.args.page_size,t,s,a);let c=await n.calculate_paging(r,l);return e.args.target!=null&&await crs.process.setValue(e.args.target,c,t,s,a),c}static async get_page(e,t,s,a){const n=await crs.process.getValue(e.args.db,t,s,a),r=await crs.process.getValue(e.args.store,t,s,a),l=await crs.process.getValue(e.args.page_size,t,s,a),c=await crs.process.getValue(e.args.page_number,t,s,a),o=await crs.process.getValue(e.args.fields,t,s,a);let u=await n.get_page(r,l,c,o);return e.args.target!=null&&await crs.process.setValue(e.args.target,u,t,s,a),u}static async get_range(e,t,s,a){const n=await crs.process.getValue(e.args.db,t,s,a),r=await crs.process.getValue(e.args.store,t,s,a),l=await crs.process.getValue(e.args.field,t,s,a);let c=await n.get_range(r,l);return e.args.target!=null&&await crs.process.setValue(e.args.target,c,t,s,a),c}}class g{constructor(){this.next_key={}}static open(e,t,s){return new Promise(a=>{let n=window.indexedDB.open(e,t||1,s),r;n.onsuccess=l=>{n.onsuccess=null,r=n.result;let c=new g;c.db=r,a(c)},n.onupgradeneeded=l=>{if(n.onupgradeneeded=null,r=l.target.result,s!=null){const o=Object.keys(s);for(const u of o){const i=r.createObjectStore(u,s[u].parameters),d=s[u].indexes;if(d!=null){const _=Object.keys(d);for(let w of _)i.createIndex(`ind_${w}`,w,d[w])}}}let c=l.target.transaction;c.oncomplete=o=>{c.oncomplete=null;let u=new g;u.db=r,a(u),c=null}}})}static delete(e){window.indexedDB.deleteDatabase(e)}static get_databases(){return window.indexedDB.databases()}get_next_key(e){let t=this.next_key[e];return t=t+1,this.next_key[e]=t,t}close(){return this.db.close(),this.db=null,this.next_key=null,null}dump(e,t){return new Promise(async s=>{await this.clear();let a=this.db.transaction([e],"readwrite"),n=a.objectStore(e);for(let r=0;r<t.length;r++){const l=t[r];l.__ind=r,n.add(l,r)}this.next_key[e]=t.length,a.oncomplete=r=>{a.oncomplete=null,e=null,a=null,s()},a.commit()})}get_from_index(e,t){return new Promise(s=>{for(let c=0;c<t.length;c++)t[c]=Number(t[c]);let a=this.db.transaction([e],"readonly"),n=a.objectStore(e),r=n.openCursor(),l=[];r.onsuccess=c=>{let o=c.target.result;if(o==null)return r.onsuccess=null,a=null,n=null,r=null,s(l);t.indexOf(o.primaryKey)!=-1&&l.push(o.value),o.continue()}})}get_values(e,t,s){return new Promise(a=>{let n=this.db.transaction([e],"readonly"),r=n.objectStore(e),l=r.openCursor(),c=[];l.onsuccess=o=>{let u=o.target.result;if(u==null)return l.onsuccess=null,n=null,r=null,l=null,a(c);if(s){if(s.indexOf(u.primaryKey)!=-1){let i=V(u.value,t);c.push(i)}}else{let i=V(u.value,t);c.push(i)}u.continue()}})}get_all(e){return new Promise(t=>{let s=this.db.transaction([e],"readonly"),a=s.objectStore(e),n=a.getAll();n.onsuccess=r=>(n.onsuccess=null,s=null,a=null,t(r.target.result))})}clear(e){return new Promise(t=>{if(this.db.objectStoreNames.contains(e)==!1)return t();let s=this.db.transaction([e],"readwrite"),a=s.objectStore(e),n=a.clear();n.onsuccess=r=>(n.onsuccess=null,s=null,a=null,t())})}delete_record(e,t){return new Promise(s=>{let a=this.db.transaction([e],"readwrite"),n=a.objectStore(e),r=n.delete(t);r.onsuccess=l=>(r.onsuccess=null,a=null,n=null,s())})}update_record(e,t,s){return new Promise(a=>{let n=this.db.transaction([e],"readwrite"),r=n.objectStore(e),l=r.put(s,t);l.onsuccess=c=>(l.onsuccess=null,n=null,r=null,a())})}add_record(e,t){return new Promise(s=>{let a=this.db.transaction([e],"readwrite"),n=a.objectStore(e),r=n.add(t,this.get_next_key(e));r.onsuccess=l=>(r.onsuccess=null,a=null,n=null,s())})}get_batch(e,t,s){return new Promise(a=>{let r=this.db.transaction([e],"readwrite").objectStore(e),l=[];const c=IDBKeyRange.bound(t,s),o=r.openCursor(c);o.onsuccess=u=>{const i=u.target.result;if(i)l.push(i.value),i.continue();else return o.onsuccess=null,a(l)}})}calculate_paging(e,t){return new Promise(s=>{const r=this.db.transaction([e],"readonly").objectStore(e).count();r.onsuccess=()=>{const l=r.result;let c=Math.ceil(l/t||1);return l>0&&c==0&&(c=1),r.onsuccess=null,s({record_count:l,page_count:c})}})}get_page(e,t,s,a){const n=s*t,r=n+t-1;if(a==null)return this.get_batch(e,n,r);{let l=[];for(let c=n;c<=r;c++)l.push(c);return this.get_values(e,a,l)}}get_range(e,t){return new Promise(s=>{const a={min:Number.MAX_VALUE,max:Number.MIN_VALUE};let n=this.db.transaction([e],"readonly"),r=n.objectStore(e),l=r.openCursor();l.onsuccess=c=>{let o=c.target.result;if(o==null)return l.onsuccess=null,n=null,r=null,l=null,s(a);const u=o.value[t];u<a.min&&(a.min=u),u>a.max&&(a.max=u),o.continue()}})}}function V(b,e){let t={};for(let s of e)t[s]=b[s];return t}crs.intent.db=f;export{f as DatabaseActions};
