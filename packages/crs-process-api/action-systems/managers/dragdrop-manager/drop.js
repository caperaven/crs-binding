async function p(t,o,a,s){const e=await c(t,o,s);e==!1?await n(o,a):await i(t,o,e,s),l(o,a)}async function n(t,o){if(await r(t,o._bounds),t._dragElement!=null){const a=t._dragElement;delete t._dragElement,t=a}o.parentElement.replaceChild(t,o)}async function i(t,o,a,s){o.parentElement.removeChild(o),a.appendChild(o)}function r(t,o){return new Promise(a=>{const s=setTimeout(()=>{t.style.transition="translate 0.3s ease-out",t.style.translate=`${o.x}px ${o.y}px`}),e=setTimeout(()=>{clearTimeout(s),clearTimeout(e),t.parentElement.removeChild(t),a()},350)})}function l(t,o){delete t._bounds,t.style.width="",t.style.height="",t.style.rotate="",t.style.translate="",t.style.transition="",t.style.filter="",delete o._bounds}async function c(t,o,a){return u[typeof a.drop.allowDrop](t,a)}class u{static async string(o,a){return o.target.matches(a.drop.allowDrop)?o.target:o.target.parentElement?.matches(a.drop.allowDrop)?o.target.parentElement:!1}static async function(o,a){return await a.drop.allowDrop(o)}static async object(o){}}export{p as drop};
