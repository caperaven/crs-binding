class e{static async perform(a,t,r,s){return this[a.action]!=null?await this[a.action](a,t,r,s):await this.do_math_api(a,t,r,s)}static async add(a,t,r,s){return await this.do_math(a,t,r,s,(i,u)=>i+u)}static async subtract(a,t,r,s){return await this.do_math(a,t,r,s,(i,u)=>i-u)}static async multiply(a,t,r,s){return await this.do_math(a,t,r,s,(i,u)=>i*u)}static async divide(a,t,r,s){return await this.do_math(a,t,r,s,(i,u)=>i/u)}static async do_math(a,t,r,s,i){const u=await crs.process.getValue(a.args.value1,t,r,s),l=await crs.process.getValue(a.args.value2,t,r,s),c=i(u,l);return a.args.target!=null&&await crs.process.setValue(a.args.target,c,t,r,s),c}static async do_math_api(a,t,r,s){const i=[],u=Array.isArray(a.args.value)?a.args.value:[a.args.value];for(let c of u){const n=await crs.process.getValue(c,t,r,s);i.push(n)}const l=Math[a.action]?.(...i);return a.args.target!=null&&await crs.process.setValue(a.args.target,l,t,r,s),l}static async normalize(a,t,r,s){const i=await crs.process.getValue(a.args.value,t,r,s),u=await crs.process.getValue(a.args.min,t,r,s),l=await crs.process.getValue(a.args.max,t,r,s),c=Number(((i-u)/(l-u)).toFixed(2));return a.args.target!=null&&await crs.process.setValue(a.args.target,c,t,r,s),c}}crs.intent.math=e;export{e as MathActions};
