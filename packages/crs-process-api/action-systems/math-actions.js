class e{static async perform(a,t,r,s){return this[a.action]!=null?await this[a.action](a,t,r,s):await this.doMathApi(a,t,r,s)}static async add(a,t,r,s){return await this.doMath(a,t,r,s,(i,c)=>i+c)}static async subtract(a,t,r,s){return await this.doMath(a,t,r,s,(i,c)=>i-c)}static async multiply(a,t,r,s){return await this.doMath(a,t,r,s,(i,c)=>i*c)}static async divide(a,t,r,s){return await this.doMath(a,t,r,s,(i,c)=>i/c)}static async doMath(a,t,r,s,i){const c=await crs.process.getValue(a.args.value1,t,r,s),u=await crs.process.getValue(a.args.value2,t,r,s),n=i(c,u);return a.args.target!=null&&await crs.process.setValue(a.args.target,n,t,r,s),n}static async doMathApi(a,t,r,s){const i=[],c=Array.isArray(a.args.value)?a.args.value:[a.args.value];for(let n of c){const l=await crs.process.getValue(n,t,r,s);i.push(l)}const u=Math[a.action]?.(...i);return a.args.target!=null&&await crs.process.setValue(a.args.target,u,t,r,s),u}}crs.intent.math=e;export{e as MathActions};
